`deleteContact`: a step-by-step break down **exactly what it does and why it works**:

```go
func deleteContact(id int) {
    contacts := loadContacts()
    var updated []Contact

    for _, c := range contacts {
        if c.ID != id {
            updated = append(updated, c)
        }
    }

    saveContacts(updated)
}
```

---

## 1. Function signature

```go
func deleteContact(id int)
```

This function takes **one parameter**:

* `id` → the ID of the contact you want to remove

It returns **nothing**, because it updates the file/database instead.

---

## 2. Load all contacts

```go
contacts := loadContacts()
```

This line calls a function (`loadContacts`) that probably:

* Reads the contact file (like `contacts.json`)
* Converts JSON into `[]Contact` (a slice of Contact structs)
* Returns that slice

Example result:

```go
contacts = [
  {ID: 1, Name: "David"},
  {ID: 2, Name: "Sarah"},
  {ID: 3, Name: "John"},
]
```

---

## 3. Create a new slice for updated, filtered contacts

```go
var updated []Contact
```

This creates an **empty slice** that will store only the contacts we want to keep.

At this point:

```
updated = []
```

---

## 4. Loop through each contact

```go
for _, c := range contacts {
```

This is a **range loop** over the slice:

| Part       | Meaning                    |
| ---------- | -------------------------- |
| `_`        | the index (we ignore it)   |
| `c`        | the current Contact struct |
| `contacts` | the original slice         |

On each iteration, `c` is one contact.

---

## 5. Filter out the contact to delete

```go
if c.ID != id {
    updated = append(updated, c)
}
```

**This is the key logic:**

* If the contact’s ID does not match the one we want to delete → **keep it**
* If the ID matches → **skip it**

That means:

| Contact ID | Want to delete? | Action   |
| ---------- | --------------- | -------- |
| 1          | ❌               | appended |
| 2          | ✅               | skipped  |
| 3          | ❌               | appended |

So `updated` becomes:

```go
[
  {ID: 1, Name: "David"},
  {ID: 3, Name: "John"},
]
```

This is a classic **filter pattern**:

> Create a new slice that contains only elements that meet a condition

---

## 6. Save the new list

```go
saveContacts(updated)
```

This probably writes the updated slice back to your file or database.

So effectively:

* Original contacts: `[1,2,3]`
* Updated contacts: `[1,3]`
* And now your stored data has NO contact with ID 2

---

## Why this approach is good

✅ Simple
✅ Safe
✅ No index shifting issues
✅ Easy to understand
✅ Works for files and databases

It avoids complex in-place slice deletion logic and just **rebuilds the slice** cleanly.

---

## Visual Diagram

```
contacts → [1] [2] [3] [4]
              ↓   ↓   ↓
updated  →  [1] [3] [4]
             ^ skip 2
```

---

## Alternative version (in-place delete)

This also works but is more advanced:

```go
func deleteContact(id int) {
    contacts := loadContacts()

    for i, c := range contacts {
        if c.ID == id {
            contacts = append(contacts[:i], contacts[i+1:]...)
            break
        }
    }

    saveContacts(contacts)
}
```

But your version is **cleaner and more beginner-friendly**.

---

## Summary — in plain English

> “Load all contacts, build a new list that excludes the one we want to delete, then save that new list.”

You used a **filter pattern** on a slice — and that is exactly the right approach ✅

---
