# Solutions

## ğŸŸ¢ 1. Sum of a slice

```go
func sum(nums []int) int {
	total := 0
	for _, n := range nums {
		total += n
	}
	return total
}
```

---

## ğŸŸ¢ 2. Reverse a slice (in place)

```go
func reverse(nums []int) {
	for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
		nums[i], nums[j] = nums[j], nums[i]
	}
}
```

---

## ğŸŸ¢ 3. Min and Max

```go
func minMax(nums []int) (int, int) {
	if len(nums) == 0 {
		return 0, 0
	}

	min, max := nums[0], nums[0]

	for _, n := range nums {
		if n < min {
			min = n
		}
		if n > max {
			max = n
		}
	}

	return min, max
}
```

---

## ğŸŸ¡ 4. Remove duplicates

### Version using a map (fastest)

```go
func removeDuplicates(nums []int) []int {
	seen := make(map[int]bool)
	var result []int

	for _, n := range nums {
		if !seen[n] {
			seen[n] = true
			result = append(result, n)
		}
	}

	return result
}
```

---

## ğŸŸ¡ 5. Filter even numbers

```go
func onlyEven(nums []int) []int {
	var result []int

	for _, n := range nums {
		if n%2 == 0 {
			result = append(result, n)
		}
	}

	return result
}
```

---

## ğŸŸ¡ 6. Insert an element at a position

```go
func insert(nums []int, index int, value int) []int {
	if index < 0 || index > len(nums) {
		return nums
	}

	nums = append(nums[:index], append([]int{value}, nums[index:]...)...)
	return nums
}
```

Example:

```go
nums := []int{1, 2, 4, 5}
nums = insert(nums, 2, 3) // [1 2 3 4 5]
```

---

## ğŸ”µ 7. Safe delete (does not modify original)

```go
func deleteAt(nums []int, index int) []int {
	if index < 0 || index >= len(nums) {
		return nums
	}

	result := make([]int, 0, len(nums)-1)

	result = append(result, nums[:index]...)
	result = append(result, nums[index+1:]...)

	return result
}
```

---

## ğŸ”µ 8. Chunk a slice

```go
func chunk(nums []int, size int) [][]int {
	if size <= 0 {
		return nil
	}

	var result [][]int

	for i := 0; i < len(nums); i += size {
		end := i + size

		if end > len(nums) {
			end = len(nums)
		}

		result = append(result, nums[i:end])
	}

	return result
}
```

---

## ğŸ”µ 9. Circular rotate right

```go
func rotate(nums []int, k int) []int {
	length := len(nums)

	if length == 0 {
		return nums
	}

	k = k % length

	return append(nums[length-k:], nums[:length-k]...)
}
```

Example:

```go
rotate([]int{1,2,3,4,5}, 2)
// â†’ [4 5 1 2 3]
```

---

## ğŸ”´ 10. Find Contact by Email

```go
type Contact struct {
	ID    int
	Name  string
	Email string
}

func findByEmail(contacts []Contact, email string) *Contact {
	for _, c := range contacts {
		if c.Email == email {
			return &c
		}
	}
	return nil
}
```

âœ… Note: Returning a pointer lets you know if the contact wasn't found (`nil`)

---

## ğŸ”´ 11. Merge two sorted slices

```go
func mergeSorted(a, b []int) []int {
	var result []int
	i, j := 0, 0

	for i < len(a) && j < len(b) {
		if a[i] < b[j] {
			result = append(result, a[i])
			i++
		} else {
			result = append(result, b[j])
			j++
		}
	}

	result = append(result, a[i:]...)
	result = append(result, b[j:]...)

	return result
}
```

Example:

```go
mergeSorted([]int{1,3,5}, []int{2,4,6})
// â†’ [1 2 3 4 5 6]
```

---

## ğŸ”´ 12. Parallel Sum (goroutines + slices + channels)

```go
func parallelSum(nums []int, workers int) int {
	if workers <= 0 {
		workers = 1
	}

	chunkSize := (len(nums) + workers - 1) / workers
	sumChan := make(chan int)

	for i := 0; i < len(nums); i += chunkSize {
		end := i + chunkSize
		if end > len(nums) {
			end = len(nums)
		}

		go func(slice []int) {
			localSum := 0
			for _, n := range slice {
				localSum += n
			}
			sumChan <- localSum
		}(nums[i:end])
	}

	total := 0
	for i := 0; i < workers && i*chunkSize < len(nums); i++ {
		total += <-sumChan
	}

	return total
}
```

---

## âœ… Bonus answers (trick questions)

### 1. What happens?

```go
a := []int{1,2,3}
b := a[:2]
b = append(b, 99)
fmt.Println(a)
```

**Answer:**

Depending on capacity:

* If a had extra capacity â†’ **a becomes [1,2,99]**
* If not â†’ b gets a NEW array and a stays unchanged

ğŸ’¡ This is why capacity matters.

---

### 2. Does this change the original?

```go
func modify(s []int) {
    s = append(s, 100)
}

nums := []int{1,2,3}
modify(nums)
fmt.Println(nums)
```

**Answer: NO (usually)**
Because append likely creates a new underlying array.

To fix:

```go
func modify(s *[]int) {
    *s = append(*s, 100)
}
```

---
