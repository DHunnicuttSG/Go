# Deep dive — validation and error handling in Go

Go’s philosophy around errors is deliberate and pragmatic: **errors are values**. 
That simple idea shapes idiomatic code, architectures, and validation strategies. 
Below we’ll show you fundamentals, idioms, patterns, concrete code examples, and practical 
advice for APIs, CLIs, and concurrent code.

---

# 1) Core principles

* **Errors are values:** `error` is an interface (`type error interface { Error() string }`). Return them, wrap them, compare them.
* **Prefer explicit handling:** check `if err != nil { ... }`. No exceptions like in other languages.
* **Wrap with context:** add useful context when propagating errors so debugging is easier.
* **Don’t leak internal details to users:** when building an API, map internal errors to safe client-facing messages/codes.
* **Panic is for programmer errors/unrecoverable states**, not validation or expected runtime failures.

---

# 2) Basic error creation & propagation

```go
import (
    "errors"
    "fmt"
)

func readFile(path string) ([]byte, error) {
    if path == "" {
        return nil, errors.New("path empty")
    }
    // ... do work
    return nil, fmt.Errorf("open %q: %w", path, err) // wrap lower-level `err`
}
```

* `errors.New` and `fmt.Errorf("...%w...", err)` (Go 1.13+) are the common ways.
* `%w` wraps an error so it can be inspected later with `errors.Is` and `errors.As`.

---

# 3) Inspecting errors: `errors.Is`, `errors.As`, `errors.Unwrap`

```go
var ErrNotFound = errors.New("not found")

// Somewhere:
return fmt.Errorf("user lookup: %w", ErrNotFound)

// Caller:
if errors.Is(err, ErrNotFound) {
    // handle not found
}
```

For typed errors:

```go
type MyError struct{ Code int; Msg string }
func (e *MyError) Error() string { return e.Msg }

var e *MyError
if errors.As(err, &e) {
    fmt.Println("code:", e.Code)
}
```

Use `errors.Is` for sentinel equality checks and `errors.As` for extracting typed errors.

---

# 4) Validation strategies — overview

For validating input you commonly pick one of:

1. **Small validation functions** returning `error` (idiomatic, simple).
2. **Aggregate validation error** that collects field errors and returns a single `ValidationError` you can inspect.
3. **Struct-tag/reflect-based validation** using a library (concise, powerful) — tradeoff: runtime reflection and dependency.
4. **Schema validation** (JSON Schema, protobuf validation) for APIs.

Which to use depends on app needs. For a small app, simple functions are sufficient; for web APIs you often want structured field errors so you can return JSON with each field error.

---

# 5) Example: simple validator functions

```go
func validateUsername(u string) error {
    if len(u) < 3 {
        return fmt.Errorf("username too short")
    }
    return nil
}

func validateAge(a int) error {
    if a <= 0 || a > 150 {
        return fmt.Errorf("invalid age %d", a)
    }
    return nil
}

// Usage
if err := validateUsername(req.Username); err != nil {
    return err
}
```

This is easy to test and compose.

---

# 6) Example: an aggregate `ValidationError` type (good for APIs)

```go
type FieldError struct {
    Field string `json:"field"`
    Err   string `json:"error"`
}

type ValidationError struct {
    Fields []FieldError `json:"fields"`
}

func (v *ValidationError) Error() string {
    // human readable summary
    if len(v.Fields) == 0 { return "validation failed" }
    return fmt.Sprintf("validation failed: %s", v.Fields[0].Field)
}

func (v *ValidationError) Add(field, msg string) {
    v.Fields = append(v.Fields, FieldError{Field: field, Err: msg})
}
func (v *ValidationError) IsEmpty() bool { return len(v.Fields) == 0 }

// Usage:
func validateUser(u User) error {
    ve := &ValidationError{}
    if u.Name == "" {
        ve.Add("name", "required")
    }
    if u.Age < 0 {
        ve.Add("age", "must be >= 0")
    }
    if ve.IsEmpty() { return nil }
    return ve
}
```

* In an HTTP handler you can `json.Marshal` `ValidationError` and return `400` with a structured body.
* Callers can `errors.As(err, &ve)` to get field details programmatically.

---

# 7) Sentinel vs typed errors: pros & cons

* **Sentinel errors** (`var ErrX = errors.New("...")`) are simple and work with `errors.Is`. But overuse can cause brittle equality checks and global state.
* **Typed errors** (custom struct implementing `Error()`) let you include fields (e.g., code, metadata) and allow `errors.As` checks. Preferred when you need programmatic handling.

Example typed error for validation:

```go
type ValidationErr struct{ Field, Reason string }
func (e ValidationErr) Error() string { return e.Field + ": " + e.Reason }

if errors.As(err, &ValidationErr{}) {
    // handle field-level programmatic behavior
}
```

---

# 8) Error wrapping best practices

* Wrap errors when adding meaningful context: `fmt.Errorf("read config: %w", err)`.
* Don’t wrap just to change the string if you don’t need the original error preserved.
* Keep the innermost error meaningful (often from standard library or a sentinel).

---

# 9) Panic vs error return

* Use `panic` only for unrecoverable programmer errors (index out of range bugs, invariant violations) or during initialization when you cannot proceed.
* For validation / invalid user input — **return errors**.

Example misuse:

```go
// BAD: panic for invalid user input
if req.Username == "" {
    panic("username required")
}
```

Correct:

```go
if err := validate(req); err != nil {
    return http.StatusBadRequest, err
}
```

---

# 10) Concurrency and errors

* When goroutines run concurrently, errors must be communicated back. Common patterns:

  * Channel of `error` (single error or struct with context).
  * `errgroup` (from x/sync/errgroup) — waits for goroutines and returns first non-nil error.
  * Aggregate errors for multiple failures.

Basic channel example:

```go
errCh := make(chan error, n)
for i := 0; i < n; i++ {
    go func(i int) {
        if err := doWork(i); err != nil {
            errCh <- fmt.Errorf("worker %d: %w", i, err)
        } else {
            errCh <- nil
        }
    }(i)
}

// collect errors
for i := 0; i < n; i++ {
    if err := <-errCh; err != nil {
        // handle
    }
}
```

Use buffered channels or synchronization to avoid goroutine leaks.

---

# 11) Context and cancellation errors

* `context` package uses sentinel errors `context.Canceled` and `context.DeadlineExceeded`.
* When you wrap or inspect errors, make sure to respect these sentinel values (`errors.Is(err, context.Canceled)`).

---

# 12) Mapping errors to HTTP responses or exit codes

When building an API, create a translation layer:

* `ValidationError` → `400 Bad Request` with JSON body of field errors.
* `ErrNotFound` → `404 Not Found`
* `ErrUnauthorized` → `401`
* Unexpected server error → `500` but log the original wrapped error for diagnostics.

Keep user-facing messages minimal and safe; log details (with correlation IDs) for internal debugging.

---

# 13) Logging and observability

* Log **wrapped** errors with full context. Use structured logging (key/value).
* Consider including stack traces only in logs — not in client responses.
* A pattern: `logger.Error("save user failed", zap.Error(err), zap.String("user", userID))` and send a generic message to client.

---

# 14) Example: end-to-end validation + error handling for HTTP

```go
type CreateUserReq struct {
    Name string `json:"name"`
    Email string `json:"email"`
}

func createUserHandler(w http.ResponseWriter, r *http.Request) {
    var req CreateUserReq
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, "bad json", http.StatusBadRequest)
        return
    }
    if err := validateUser(req); err != nil {
        var ve *ValidationError
        if errors.As(err, &ve) {
            w.WriteHeader(http.StatusBadRequest)
            json.NewEncoder(w).Encode(ve)
            return
        }
        // fallback
        http.Error(w, "invalid request", http.StatusBadRequest)
        return
    }

    if err := storeUser(req); err != nil {
        // wrap and log
        log.Printf("store user: %v", err)
        http.Error(w, "internal error", http.StatusInternalServerError)
        return
    }

    w.WriteHeader(http.StatusCreated)
}
```

* This shows structured validation response and safe internal logging.

---

# 15) Advanced & production considerations

* **Third-party validators** (struct tags + reflection) speed development for forms/JSON, but add runtime complexity and reduce compile-time safety.
* **Error codes vs messages:** For machine consumption, include stable error codes (e.g., `code: "user_exists"`) in response bodies.
* **Testing:** unit-test validation functions extensively; test error wrapping/inspection too.
* **Security:** scrub sensitive fields (passwords, tokens) from logs and error messages.

---

# 16) Short recipes (copy-paste)

### Create and check sentinel

```go
var ErrDuplicate = errors.New("duplicate")

if errors.Is(err, ErrDuplicate) {
    // handle
}
```

### Wrap and extract typed error

```go
type DBError struct{ Op string; Err error }
func (d DBError) Error() string { return d.Op + ": " + d.Err.Error() }
func (d DBError) Unwrap() error { return d.Err }

// Wrap
return DBError{Op: "insert", Err: sqlErr}

// Extract
var de DBError
if errors.As(err, &de) {
    fmt.Println("DB op:", de.Op)
}
```

### Validation error aggregate to JSON

```go
ve := &ValidationError{}
ve.Add("email", "invalid format")
if !ve.IsEmpty() {
    w.WriteHeader(400)
    json.NewEncoder(w).Encode(ve)
    return
}
```

---

# 17) TL;DR — best practices

* Return `error` for expected failure cases; avoid panic.
* Wrap errors with `%w` and add context.
* Use `errors.Is` for sentinel comparisons, `errors.As` for typed extractions.
* For validation use small testable validators or a structured `ValidationError` that you can jsonify.
* Map internal errors to safe client responses; log the wrapped error for debugging.
* In concurrent code, propagate errors via channels or `errgroup`.

---
