## 1. What is a slice (really)?

A **slice is not an array**. It is a descriptor pointing to an array.

Internally, a slice is a small structure with **three fields**:

```go
type SliceHeader struct {
    Data uintptr  // pointer to underlying array
    Len  int      // current length
    Cap  int      // capacity (max size without realloc)
}
```

So when you write:

```go
nums := []int{1, 2, 3}
```

You‚Äôre actually creating:

```
Slice
 ‚îú‚îÄ‚îÄ pointer ‚Üí [1 2 3 ?? ??]
 ‚îú‚îÄ‚îÄ length = 3
 ‚îî‚îÄ‚îÄ capacity = maybe 3 or more
```

The **underlying array exists separately**.

> üîë Key idea:
> **Slices = view into an array.** Multiple slices can share the same backing array.

---

## 2. Slice vs Array (important for interviews)

| Array                               | Slice                      |
| ----------------------------------- | -------------------------- |
| Fixed size                          | Dynamic size               |
| Part of type (`[5]int` != `[6]int`) | Not part of type (`[]int`) |
| Value type (copied fully)           | Reference-like             |
| Less commonly used                  | Used everywhere            |

Example:

```go
var a [3]int = [3]int{1,2,3} // array
var s []int = []int{1,2,3}   // slice
```

Passing to a function:

* An **array** copies all values
* A **slice** passes a reference

---

## 3. Length vs Capacity (CRITICAL concept)

```go
s := []int{1,2,3,4}
fmt.Println(len(s)) // 4
fmt.Println(cap(s)) // maybe 4, 6, or more
```

* **Length** = actual elements in use
* **Capacity** = how many can be stored without resizing

Example:

```go
s := make([]int, 3, 10)
```

This means:

```
length  = 3 ‚Üí [0 0 0]
capacity = 10 ‚Üí space for 7 more
```

This is useful for performance.

---

## 4. What really happens with append()

When you do:

```go
s = append(s, 99)
```

Two possibilities:

### Case 1: Enough capacity ‚Üí Uses same array

```
Before: [1 2 3  _  _  _], cap=6
After:  [1 2 3 99 _  _]
```

### Case 2: No space ‚Üí Creates NEW bigger array

```
Before: [1 2 3], cap=3
append -> NEW ARRAY [1 2 3 99 ?? ??], cap ~ 6
```

**This is critical:**

```go
func add(s []int) {
    s = append(s, 100) // might create new array
}

nums := []int{1,2,3}
add(nums)
fmt.Println(nums) // might NOT have 100
```

‚úÖ Fix by returning the slice:

```go
func add(s []int) []int {
    s = append(s, 100)
    return s
}
```

Or by using pointer:

```go
func add(s *[]int) {
    *s = append(*s, 100)
}
```

---

## 5. Slicing a slice (dangerous but powerful)

```go
original := []int{1,2,3,4,5}
part := original[1:4]  // {2,3,4}
```

This **does not copy data**.

```
part shares same array as original
```

If you modify one:

```go
part[0] = 99
fmt.Println(original) // [1 99 3 4 5]
```

### To create a true copy:

```go
copy := append([]int{}, original...)
```

Or:

```go
copy := make([]int, len(original))
copy(copy, original)
```

---

## 6. How to delete from a slice

There‚Äôs no built-in delete. Here‚Äôs the pattern:

```go
s = append(s[:i], s[i+1:]...)
```

Example:

```go
s := []int{10, 20, 30, 40}
s = append(s[:1], s[2:]...)
fmt.Println(s) // [10 30 40]
```

Visual:

```
s[:1]  => [10]
s[2:]  => [30,40]
```

---

## 7. 2-D slices (dynamic matrices)

```go
matrix := [][]int{
    {1,2,3},
    {4,5,6},
}
```

Or dynamic:

```go
rows := 3
cols := 4
matrix := make([][]int, rows)

for i := range matrix {
    matrix[i] = make([]int, cols)
}
```

This is not one continuous memory block like C ‚Äî each row is separate.

---

## 8. Performance tips (real world)

‚ùå BAD

```go
var logs []string
for i := 0; i < 1_000_000; i++ {
    logs = append(logs, "log")
}
```

‚úÖ GOOD

```go
logs := make([]string, 0, 1_000_000)
```

Pre-allocating capacity can make code **2x‚Äì10x faster**.

---

## 9. Passing slices to functions

Slices behave like **references**

```go
func change(s []int) {
    s[0] = 999
}

nums := []int{1,2,3}
change(nums)
fmt.Println(nums) // [999 2 3]
```

Because they share the same backing array.

---

## 10. Practical example for your Contact App

```go
contacts := []Contact{}

contacts = append(contacts, Contact{ID:1, FirstName:"David"})
contacts = append(contacts, Contact{ID:2, FirstName:"Sarah"})

// Find contact
for _, c := range contacts {
    if c.ID == 1 {
        fmt.Println(c.FirstName)
    }
}
```

Delete a contact:

```go
func deleteByID(list []Contact, id int) []Contact {
    for i, c := range list {
        if c.ID == id {
            return append(list[:i], list[i+1:]...)
        }
    }
    return list
}
```

---

## 11. Diagram ‚Äî what a slice looks like

```
Slice s
+------------------------+
| pointer | len | cap  |
+------------------------+
      |
      v
[ 5 | 8 | 2 | 9 | _ | _ | _ ]
 0   1   2   3   4   5   6
```

Two slices can point to the SAME array:

```
s1 = [5 8 2]
s2 = [8 2 9]
     ‚Üë they share memory
```

---

## 12. Common slice interview questions

‚úÖ Q: Is a slice a pointer?

> No. It *contains* a pointer but also length and capacity.

‚úÖ Q: Does slicing copy?

> No. It shares memory.

‚úÖ Q: How do you prevent memory leak with big slices?

> Copy only what you need.

---
